<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pickleball Court Snapshot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body{background:#111;color:#fff;font-family:system-ui,Arial;margin:0;text-align:center}
    header{padding:16px 12px 0}
    .meta{color:#bbb;font-size:14px;margin:6px 0 18px}
    img{width:90%;max-width:1400px;height:auto;border:4px solid #444;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,.35)}
    .row{display:flex;gap:12px;justify-content:center;align-items:center;margin:12px 0 24px;flex-wrap:wrap}
    .pill{background:#222;border:1px solid #444;border-radius:999px;padding:6px 12px;cursor:default}
    button.pill{cursor:pointer}
  </style>
</head>
<body>
  <header>
    <h1 style="margin:0 0 8px">Pickleball Court</h1>
    <div class="row">
      <div class="pill">Next refresh in: <span id="count">--:--</span></div>
      <button id="refresh" class="pill" aria-label="Refresh now">Refresh now</button>
    </div>
    <div class="meta">Image updates every ~2 minutes. Page holds at 00:00 for 15s, then shows “waiting…” if late.</div>
    <div id="status" class="meta"></div> <!-- debug line -->
  </header>

  <img id="snap" src="" alt="Latest snapshot">

<script>
  // Cadence & polling
  const PUBLISH_INTERVAL_MS = 120000;   // 2 minutes
  const META_POLL_MS        = 3000;     // check meta every 3s
  const IMAGE_REFRESH_MS    = 10000;    // opportunistic reload
  const PIPELINE_OFFSET_MS  = 5000;     // small GH delay

  // Data repo base (use main -> master if your branch is master)
  const DATA_BASE = 'https://raw.githubusercontent.com/SJ-COGV/COGV-Pickleball-Cam-Data/main/';
  const META_URL  = DATA_BASE + 'meta.json';

  const snap     = document.getElementById('snap');
  const countEl  = document.getElementById('count');
  const statusEl = document.getElementById('status') || {textContent: ''};

  let lastPublished = Number(localStorage.getItem('lastPublishedMs') || 0);
  let nextTarget    = lastPublished
    ? (lastPublished + PIPELINE_OFFSET_MS + PUBLISH_INTERVAL_MS)
    : (Date.now() + PIPELINE_OFFSET_MS + PUBLISH_INTERVAL_MS);
  let stalled       = false;
  let holdAtZeroUntil = null;
  let currentImageName = null; // from meta.image

  function fmt(ms){
    const s = Math.max(0, Math.floor(ms/1000));
    const m = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s % 60).padStart(2,'0');
    return `${m}:${ss}`;
  }
  function renderStatus(ts){
    statusEl.textContent = ts ? ('Last meta: ' + new Date(ts).toLocaleString()) : 'Last meta: (none yet)';
  }
  function showWaiting(){ stalled = true; countEl.textContent = 'waiting…'; }
  function setImageByName(name){
    if (!name) return;
    currentImageName = name;
    snap.src = DATA_BASE + name; // filename changes each publish → bypasses caches
  }
  function resumeFrom(ts, name){
    stalled = false;
    lastPublished = ts;
    localStorage.setItem('lastPublishedMs', String(ts));
    holdAtZeroUntil = null;
    nextTarget = ts + PIPELINE_OFFSET_MS + PUBLISH_INTERVAL_MS;
    renderStatus(ts);
    setImageByName(name);
  }

  async function loadMeta(){
    try{
      const res = await fetch(META_URL + '?t=' + Date.now(), { cache: 'no-store' });
      if(!res.ok) return false;
      const meta = await res.json();
      const ts = Date.parse(meta.lastPublished);
      const name = meta.image; // e.g. snapshot-20250828T011530Z.jpg

      if(Number.isFinite(ts)) renderStatus(ts);
      if (name && name !== currentImageName) {
        // update image immediately even if timestamp hasn't changed (safety)
        setImageByName(name);
      }
      if(Number.isFinite(ts) && ts > lastPublished){
        resumeFrom(ts, name);
      }
      return true;
    }catch{ return false; }
  }

  function tick(){
    if(stalled) return;
    const rem = nextTarget - Date.now();
    if(rem > 0){
      countEl.textContent = fmt(rem);
      holdAtZeroUntil = null;
      return;
    }
    if(holdAtZeroUntil === null){ holdAtZeroUntil = Date.now() + 15000; }
    countEl.textContent = '00:00';
    loadMeta();
    if(Date.now() >= holdAtZeroUntil){ showWaiting(); }
  }

  // Optional: a “Refresh now” button with id="refresh"
  const refreshBtn = document.getElementById('refresh');
  if (refreshBtn) refreshBtn.addEventListener('click', () => { loadMeta(); });

  (async function init(){
    renderStatus(lastPublished || null);
    countEl.textContent = lastPublished ? fmt(nextTarget - Date.now()) : 'syncing…';

    // First sync, then start intervals
    await loadMeta();
    setInterval(loadMeta, META_POLL_MS);
    setInterval(() => { if(!stalled){ loadMeta(); } }, IMAGE_REFRESH_MS);
    setInterval(tick, 1000);
    tick();
  })();
</script>

</body>
</html>

